1)Здравствуйте, меня зовут белоусов...

2) весь мой проект доступен на моём гитхаб-аккаунте, включая данную презентацию

3)пока вы читаете цитату великого Бьорна Страуструпа на экране презентации, я хочу рассказать о том,
как мне пришла идея написать свой язык программирования: мне с детства нравилось создавать программы --
сначала это был скретч, потом, после начала информатики в школе, моими инструментами стали С++, Python. C#...
Но, недавно я задумался, а как же работают сами языки программирования? Как компьютер понимает код, который 
вводит пользователь? 

Поэтому я прочитал множество статей, несколько книг, а после того, как немного разобрался в теме
создания компиляторов, решил создать свой простой язык и просто поэкспериментировать.

4)В итоге появился язык ЛИС -- небольшой компилятор в JavaScript, который обладает всеми 
необходимыми языковыми средствами для написания программ: (смотри слайд)
...перечисление функций языка...
На этом языке, при его простоте, можно написать огромный спектр программ,
на нем даже можно решать задачи или рисовать на холсте

5) цели проекта
зачитываю цели со слайда

6)Сейчас я расскажу, как создавался проект, какие методы и технологии
я использовал при написании своего языка, из каких частей состоят все современные компиляторы,
расскажу про их собственную реализацию

7) Первая стадия компиляции -- это лексер, или лексический анализатор. лексер
разбивает входной текст программы на поток токенов, или лексем, для облегчения работы парсера.

8) На данном слайде вы можете видеть простой пример программы на моём языке,
которая выводит строку Hello World, и вот как её разбивает лексер на три токена: 
print -- это идентификатор, "Hello world" -- это строка, а ; -- знак пунктуации

9) Для построения лексера я изначально использовал лишь стандартную функцию JS -- регулярные 
выражения, но когда мне понадобилось создавать более продвинутую и сложную грамматику языка,
я сделал выбор в пользу библиотеки moo.js, которая является генератором лексических анализаторов для
языка JavaScript и помогает быстро вносить изменения в грамматике

10) Следующим шагом компиляции является парсер. Парсер чаще всего является
рекурсивной функцией, которая на вход получает поток токенов, а на выходе дает
абстрактное синтаксическое дерево. 

11) пример: парсер получает на вход поток из трех токенов (), а на выходе дает
обьект, полностью представляющий вызов функции. Если провести аналогию
с человеческим языком, то лексер разбивает программу на слова,
а парсер строит из этих слов предложения.

12) для парсера я изначально использовал лишь свою рекурсивную реализацию,
но когда грамматика языка стала достаточно сложной, то я сделал выбор в сторону 
библиотеки Nearley.js: ты сначала описываешь в специальном формате (который называется EBNF -- 
Расширенная форма Бэкуса Наура) свой язык, а библиотека сама строит тебе парсер. Притом Nearley.js
чудесно интегрирован с прошлой библиотекой moo и имеет подробную документацию. 
поэтому я сделал выбор именно в пользу Nearley.

13) Последний шаг -- исполнитель. Он превращает абстрактное синтаксическое дерево
в понятный компьютеру язык (в нашем случае -- JavaScript), настраивает окружение (определяет
некоторые глобальные переменные, функции), а потом запускает скомпилированный код

На это часть теории подошла к концу.

14) Среда исполнения бла бла бла написание скрипта, его запуск, сохранение, загрузка...

15) Просто зачитать слайд

16-конец) комментирую примеры программ
отличия: убраны скобочки, английский язык, знакомые конструкции,
приятно глазу...